C o m p o s i t e

Свойства шаблона
Тип: структурный
Уровень: компонент

Назначение
Предоставление гибкого механизма для создания иерархических древовидных
структур произвольной сложности, элементы которых могут свободно взаимодейст-
вовать с единым интерфейсом.

Представление
Допустим, разработчик решает расширить возможности PIM-приложения, пре-
доставив в распоряжение пользователя средства управления сложным проектом.
В состав таких средств входят средства определения проекта в виде совокупности
групп этапов проекта и связанных с последними подэтапов, а также средства, обеспе-
чивающие ассоциацию результатов проекта с этапами. С точки зрения программиста,
наиболее естественный способ решения этой задачи состоит в определении древо-
видной структуры, в которой от корневого этапа (представляющего собственно про-
ект) ответвляются подпроекты, "подподпроекты" и т.д. Иными словами, нужно опре-
делить класс Task, содержащий коллекцию ссылок на экземпляры классов Task и
D e l i v e r a b l e . Поскольку классы Task и D e l i v e r a b l e являются лишь разными со-
ставляющими одного и того же проекта, достаточно определить для них только один
шаблон — класс P r o j e c t l t e m .
Однако что делать в тех случаях, когда пользователю понадобится выполнить ка-
кую-то операцию сразу над всем деревом? Например, руководителю проектов нужно
получить оценку временных затрат для выполнения всех этапов и получения всех
продуктов одного из своих проектов. Для того чтобы снабдить его средствами для
выполнения этой задачи, разработчик должен написать программный код, который
последовательно проходил бы по всем ветвям дерева, вызывая соответствующие ме-
тоды каждой ветви. Но такой подход подразумевает немалый объем работы — нужно
создать специальный программный код для перемещения по дереву, вызова всех ме-
тодов и накопления результатов. Кроме того, так как в каждой ветви в общем случае
могут в произвольном порядке встречаться экземпляры двух разных классов (Task и
D e l i v e r a b l e ) , необходимо при подсчете оценки временных затрат обрабатывать их
по-разному. Таким образом, при большом количестве классов или сложной структуре
дерева требуемый программный код быстро становится трудноуправляемым.
Конечно же, существует и более эффективный способ решения описанной про-
блемы. Этот способ заключается в применении шаблона Composite, который, опира-
ясь на такие идеи, как полиморфизм и рекурсия, предоставляет разработчику эффек-
тивное, простое и удобное в сопровождении решение.
Для начала нужно определить во всех классах, которые могут предоставлять оцен-
ку временных затрат, некий стандартный метод, скажем, getTimeRequired. Этот ме-
тод нужно определить в интерфейсе P r o j e c t l t e m , а затем реализовать его во всех
классах, имеющих тип P r o j e c t l t e m . Понятно, что у класса D e l i v e r a b l e метод
getTimeRequired возвращает значение 0, так как результат этапа может либо про-
сто отсутствовать, либо присутствовать, но его существование никак не связано с
временными затратами. Что касается класса Task, возвращаемое значение складыва-
ется из временных затрат текущего этапа и суммы, полученной с помощью вызова ме-
тода getTimeRequired всех дочерних экземпляров класса Task.
Метод getTimeRequired, разработанный в соответствии с шаблоном Composite,
автоматически вычисляет планируемые временные затраты для любой части дерева.
Достаточно лишь вызвать метод getTimeRequired того этапа (т.е. того экземпляра
класса Task), по которому нужно получить оценку временных затрат, и программный
код метода сам выполнит всю работу по перемещению по дереву и вычислению ре-
зультатов.

Область применения
Шаблон Composite рекомендуется применять в следующих случаях.
• Имеется компонентная модель древовидной структуры ("целое — часть" или
"хранилище — хранимое").
• Структура имеет произвольный уровень сложности и по своей природе дина-
мична.
• Необходимо обеспечить единый подход к работе с компонентами структуры,
используя одни и те же операции на всех уровнях иерархии.

Описание
Разработчики, придерживающиеся объектно-ориентированных принципов про-
граммирования, часто при разработке компонентов стремятся использовать модель
"целое — часть" (whole — part). В соответствии с ней, коллекции идентичных объектов
(частей) рассматриваются как единая сущность (целое). Обычно такие структуры
должны быть достаточно гибкими и простыми в использовании. Что касается пользо-
вателей, то им должны предоставляться средства модификации структуры в процессе
работы приложения, добавляя или удаляя части по своему усмотрению. В то же время
лучше всего скрыть сложность структуры "за кулисами", предоставив пользователям
лишь единый, монолитный продукт.
Для того чтобы шаблон Composite соответствовал этим требованиям, необходимо
определить такую структуру классов, которая поддерживала бы расширяемость. Такая
структура состоит из классов компонента и узла, а также класса, объединяющего их в
единое целое.
• Класс базового компонента обеспечивает модель сущности, определяя стандарт-
ные методы или переменные, которые будут использоваться всеми объектами
шаблона Composite.
• Класс узла предназначен для реализации функциональности терминальной точ-
ки. Иными словами, он представляет такие объекты, которые также входят в
единое целое, но сами они не могут содержать других компонентов.
• Объединяющий класс, соответствующий всей ветви, обеспечивает добавление но-
вых компонентов, а поэтому и расширяемость своей структуры.
Типовым примером применения на практике шаблона Composite является чер-
теж, созданный с помощью графического редактора. С отдельными элементами тако-
го чертежа, представляющими собой графические примитивы, можно работать как с
единым целым, поскольку они включены в чертеж. Кроме того, один чертеж может
содержать в себе как другие чертежи, так и любые комбинации графических прими-
тивов и чертежей любой сложности.
Шаблон Composite может также с успехом использоваться в таких приложениях, как
организационные диаграммы, рабочие графики и т.п. Приложения, в которых исполь-
зуются группы, также хорошо подходят для реализации шаблона Composite, конечно,
при том условии, что операции группирования можно выполнять рекурсивно и что
итоговый продукт, равно как и его элементы, имеет единую функциональность.

Реализация
Диаграмма классов шаблона Composite представлена на рис. 3.4.
Шаблон Composite подразумевает создание трех следующих элементов.
• Component — это интерфейс, определяющий методы, которые должны быть
доступными всем частям древовидной структуры. В тех случаях, когда требует-
ся обеспечить стандартное поведение всех подтипов, можно выполнить
Component в виде абстрактного класса. Обычно в приложении не создаются
экземпляры этого класса, а используются экземпляры его подклассов или реа-
лизующие классы, называемые узлами, из которых и образуется древовидная
структура.
• Composite— это класс, представляющий собой композицию своих компонен-
тов, т.е. функциональность его определяется содержащимися в нем компонен-
тами. Поскольку класс Composite должен предоставлять возможность получе-
ния динамических групп объектов Component, в нем имеются методы добавле-
ния экземпляров класса Component в коллекцию и методы их удаления из нее.
Методы, определенные в классе Component, реализуются таким образом, что-
бы, во-первых, они выполняли функции, характерные для содержащего экзем-
пляры компонентов объекта Composite, а во-вторых, чтобы они вызывали та-
кие же методы для каждого из своих узлов. Такие классы Composite часто на-
зывают классами ветвей или контейнеров.
• Node — класс, реализующий интерфейс Component и предоставляющий реализа-
цию для каждого метода Component. Различие между классами Compos i t e и Node
состоит в том, что последний не содержит никаких ссылок на другие экземпляры
класса Component. Иными словами, совокупность объектов Node представляет
собой самый нижний, или пограничный, уровень всей структуры в целом.
При реализации данного шаблона необходимо решить, должен ли каждый компо-
нент иметь ссылку на свой контейнер (т.е. экземпляр класса Composite). Наличие та-
кой ссылки, с одной стороны, позволяет облегчить перемещение по дереву, а с другой —
ведет к снижению гибкости приложения.

Достоинства и недостатки
Шаблон Composite дает разработчику возможность использования весьма удачной
комбинации: с одной стороны — это достаточно гибкая структура, а с другой — чрез-
вычайно удобный в управлении интерфейс.
Структура может меняться в любое время путем добавления и удаления объектов
класса Component с помощью вызова соответствующих методов экземпляра класса
Composite. С другой стороны, возможность заменять компоненты ветви означает, что
у разработчика имеется возможность изменить и поведение всего класса ветви в целом.
Отдельным достоинством шаблона является то, что в любом месте древовидной
структуры нужно всегда вызывать один и тот же метод индивидуальных компонентов.
Использование интерфейсов еще более увеличивает гибкость. Интерфейсы по-
зволяют создавать на основе шаблона целые базовые системы (framework), поддер-
живающие добавление новых типов во время работы приложения.
С другой стороны, применение интерфейсом может обернуться и другой сторо-
ной в тех случаях, когда нужно определить атрибуты и реализовать используемые по
умолчанию функции, которые должны быть унаследованы всеми узлами. В таком слу-
чае лучше определять Component в виде абстрактного класса.
Еще один недостаток шаблона является следствием его достоинства, а именно вы-
сокой гибкости. Нетрудно догадаться, что реализация динамического по своей сути
шаблона Composite может быть сопряжена с проблемами при тестировании и отлад-
ке. Обычно это выражается в том, что разработчик должен позаботиться о выработке
гораздо более серьезной стратегии тестирования и проверки работоспособности
приложения, чем в том случае, когда используется традиционная концепция иерар-
хии объектов вида "целое — часть". Если тестирование окажется слишком сложным,
лучше всего встроить средства тестирования непосредственно в реализацию класса
Composite.
Кроме всего вышесказанного, для успешной реализации шаблона Composite, как
правило, требуется либо заранее знать моделируемую структуру (иными словами,
иметь детализированную архитектуру класса Composite), либо иметь развитой меха-
низм подгрузки классов. Интерфейсная форма такого шаблона, которая подробнее
рассматривается в следующем подразделе "Варианты", может стать полезной альтер-
нативой для обеспечения динамической корректировки поведения системы во время
выполнения.

Варианты
Среди различных вариантов реализации шаблона Composite можно выделить сле-
дующие типичные решения.
• Корневой узел. Для повышения управляемости в системе некоторые разработчики,
реализующие шаблон Composite, определяют один объект, отличающийся от ос-
тальных объектов и работающий в качестве базы для всей иерархии объектов,
выполненной в соответствии с шаблоном Composite. Если такой корневой объект
представлен в виде отдельного класса, при его реализации можно использовать
шаблон Singleton. Второй подход заключается в предоставлении доступа к корне-
вому объекту, который не имеет ничего общего с шаблоном Singleton, посредст-
вом экземпляра класса, выполненного в соответствии с этим шаблоном.
• Создание ветвей на основе правил. В структурах высокой сложности (обычно тако-
выми являются структуры, объединяющие множество разнотипных узлов и
ветвей) часто применяется механизм, определяющий, как и при каких условиях
узлы могут добавляться к ветвям определенных типов.

Родственные шаблоны
К родственным относятся следующие шаблоны.
• Chain of Responsibility (стр. 62). Использование этого шаблона вместе с шабло-
ном Composite позволяет "распространять" метод вверх по дереву, т.е. от узлов
к ветвям.
• Flyweight (стр. 196). Когда древовидная структура становится слишком объем-
ной, для уменьшения количества избыточных или подобных объектов можно
воспользоваться шаблоном Flyweight.
• Iterator (стр. 87). Этот шаблон может применяться совместно с шаблоном
Composite для инкапсуляции функциональности перемещения по дереву, если
она становится слишком сложной.
• Visitor (стр. 136). При использовании этого шаблона обеспечивается централи-
зация функциональности, которая при использовании лишь одного шаблона
Composite должна распределяться по классам ветвей и узлов.
• Composite View [CJ2EEP]. Шаблон Composite описывает, как по отдельным
представлениям (view) получить некое единое представление, которое в свою
очередь может входить в представление более высокого уровня, что делает его
подобным шаблону Composite.