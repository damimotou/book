Adapter
Также известен как Wrapper

Свойства шаблона
Тип: структурный
Уровень: компонент

Назначение
Обеспечение взаимодействия двух классов путем преобразования интерфейса од-
ного из них таким образом, чтобы им мог пользоваться другой класс.

Представление
Одним из часто упоминаемых преимуществ объектно-ориентированного про-
граммирования является возможность повторного использования кода. Так как дан-
ные и поведение моделируемой сущности централизованы в виде некоторого класса,
можно (во всяком случае, такая возможность существует в принципе) просто перене-
сти этот класс из одного проекта в другой и с минимальными усилиями использовать в
новом проекте его функциональность.
К сожалению, разработчики не всегда могут абсолютно точно предвидеть после-
дующие ситуации. Поэтому, не зная наперед, какие требования будут выдвигаться к
написанию исходного кода будущих проектов, он далеко не всегда имеет возможность
выбрать оптимальную архитектуру класса, обеспечивающую безусловное повторное
использование кода.
Представим, что для ускорения работы над PIM-приложением вы решили объеди-
нить усилия с одним из своих друзей, проживающим в другом государстве. Он уже ра-
ботал над подобным проектом и может предоставить в ваше распоряжение уже реа-
лизованную на практике и успешно работающую адресную систему. Однако, получив
файлы, вы узнаете, что интерфейс этой системы не соответствует разработанным ва-
ми интерфейсам. Что еще хуже, в названиях классов и методов вместо слов англий-
ского языка используются слова родного языка вашего друга.
Итак, у вас есть выбор из двух малопривлекательных решений.
• Первое решение — переписать новый компонент таким образом, чтобы он реа-
лизовывал все требуемые интерфейсы. Переписывание нового компонента
нельзя назвать наилучшим способом решения проблемы, поскольку вам при-
дется проделывать эту работу вновь и вновь при каждом поступлении от вашего
друга обновленной им версии компонента.
• Второе решение — переписать ваше приложение таким образом, чтобы оно
могло работать с новыми интерфейсами, созданными другим разработчиком с
использованием языка, отличного от английского. Недостаток этого решения
состоит в том, что вам придется проделать огромный объем работы, внося из-
менения в исходный код целого приложения. Кроме того, после внесения та-
ких изменений вам будет труднее разобраться в собственном программном ко-
де, так как вы не знаете языка, на котором разговаривает ваш друг, — все назва-
ния, которые, с точки зрения вашего друга, говорят сами за себя, для вас будут
лишь бессмысленным набором букв.
Итак, поскольку ни одно из решений нельзя назвать удовлетворительным, а с ком-
понентом нужно что-то делать, вы решаете, что нуждаетесь в неком подобии перево-
дчика — компоненте, который бы преобразовывал вызовы одного интерфейса в вы-
зовы другого. Такое решение существует и реализуется в соответствии с шаблоном
Adapter. Его работа напоминает работу блока питания, который преобразует один
тип электрического тока в другой, несовместимый с первым. Используя шаблон
Adapter, ваше приложение может по-прежнему работать со своими интерфейсами и
при этом задействовать новые компоненты. Если же будет получена новая версия
стороннего компонента, нужно будет внести изменения в классы, созданные в соот-
ветствии с шаблоном Adapter.

Область применения
Шаблон Adapter рекомендуется применять в следующих случаях.
• В уже имеющуюся среду необходимо подключить объект, который работает с
интерфейсом, отличным от интерфейсов, реализованных в этой среде.
• Возникают ситуации, в которых требуется трансляция интерфейсов, посту-
пающих от разных разработчиков.
• Объект должен выполнять роль посредника для целой группы классов, но ка-
кой именно класс будет использован во время работы приложения, на этапе
разработки точно не известно.

Описание
Иногда возникает необходимость в использовании класса в новом для него окру-
жении, но при этом хотелось бы не заниматься его "подгонкой". В таких случаях
можно создать специальный класс, например, Adapter, и возложить на него задачу
трансляции вызовов. Для обращения к методам встраиваемого класса чуждая для него
среда обращается не к этому классу, а к методам класса Adapter, который преобразу-
ет их в вызовы методов встраиваемого класса.
Типичными представителями приложений, в которых может оказаться полезным
шаблон Adapter, являются графические, текстовые или мультимедийные редакторы,
поддерживающие подключаемые модули (plug-in). Кроме того, к разряду таких при-
ложений можно отнести Web-броузеры, а также любые приложения, поддерживаю-
щие многоязычность, и приложения, использующие подключение компонентов во
время работы (например, JavaBeans).
Примером реализации шаблона Adapter является так называемый разговорник —
небольшая книга с набором фраз, как минимум, на двух языках, представляющих со-
бой вопросы и ответы на них для большинства типичных ситуаций, в которых может
оказаться человек, попавший в другую страну. Используя этот разговорник, он может,
совершенно не владея иностранным языком, задать вопрос и получить на него более
или менее вразумительный ответ, общаясь с иностранцем, который не знает ни одно-
го слова на его родном языке.

Реализация
При реализации шаблона Adapter обычно используются следующие классы.
• Framework — этот класс использует интерфейс A d a p t e r и либо создает новый
объект класса C o n c r e t e A d a p t e r , либо получает на него ссылку из какого-либо
источника.
• A d a p t e r — интерфейс, определяющий методы, которые используются классом
Framework.
• C o n c r e t e A d a p t e r — реализация интерфейса A d a p t e r . Этот класс хранит
ссылку на экземпляр Adaptee и транслирует вызовы методов, поступающие от
экземпляра класса Framework, в вызовы методов экземпляра класса Adaptee.
При трансляции может выполняться преобразование (wrapping), или модифи-
кация, параметров и возвращаемых значений.
• Adaptee — интерфейс, в котором определены методы, подлежащие адаптации.
Этот интерфейс позволяет конкретной реализации адаптируемого класса ди-
намически подгружаться во время выполнения приложения.
• C o n c r e t e A d a p t e e — реализация интерфейса Adaptee. Класс, который должен
быть адаптирован для того, чтобы его мог использовать класс Framework.
В тех случаях, когда взаимодействие нового компонента со средой носит сложный
характер, рекомендуется составлять схему обработки вызовов, чтобы лучше понять,
как управлять взаимодействием классов приложения. Схема обработки вызовов — это
таблица, в которой показано, как объект-адаптер транслирует вызовы методов и со-
гласует параметры при взаимодействии рабочей среды и адаптируемого объекта.
В табл. 3.1 приведен пример схемы обработки вызовов для одного объекта.
Лучше всего подобные схемы представлять в среде, использующей универсальный
язык моделирования (UML — Unified Modeling Language), например, в виде последо-
вательной диаграммы (sequence diagram). Пример такой диаграммы представлен на
рис. 3.2.

Достоинства и недостатки
Шаблон Adapter значительно повышает степень повторного использования про-
граммного кода, позволяя взаимодействовать двум или более объектам, которые без
его помощи были бы несовместимыми. Однако для того чтобы рабочую среду прило-
жения можно было бы без особых проблем адаптировать для работы с классами сто-
ронних разработчиков, необходимо с самого начала как следует продумать архитек-
туру такой среды. Это требует рассмотрения двух аспектов: функциональной структу-
ры вызовов и трансляции параметров.
Если имеется функциональное несоответствие между вызовами, поступающими из
рабочей среды, и адаптируемым объектом, объект-адаптер должен обеспечить, чтобы
выполнялись все требования для вызовов методов адаптируемого объекта, в том чис-
ле он должен вызвать, если это нужно, дополнительные методы настройки, прежде
чем поступит вызов из рабочей среды.
Вторая проблема, которую должен решать объект-адаптер, состоит в корректной
трансляции параметров, так как далеко не всегда параметры, передаваемые из рабо-
чей среды, совместимы с параметрами, с которыми работает адаптируемый объект. В
таких случаях объект-адаптер обычно либо создает нужные объекты, если между па-
раметрами среды и вызываемого объекта нет прямого соответствия, либо преобразу-
ет объект таким образом, чтобы с ним мог работать адаптируемый объект.
Большинство сред общего назначения, в которых используется шаблон Adapter,
обычно строится вокруг шаблона Command, используя определенные формы обмена
сообщениями или получение информации о классах и объектах (introspection), а так-
же динамическую подгрузку классов (reflection) во время выполнения. В самом общем
случае шаблон Command может избавить разработчика от необходимости в исполь-
зовании шаблона Adapter. (См. раздел "Command" на стр. 71.)

Варианты
По самой своей природе объекты-адаптеры динамичны, поэтому среди них вряд
ли можно найти два абсолютно одинаковых. Тем не менее, можно отметить несколь-
ко общих вариантов. Ниже изложены особенности трех из множества возможных ва-
риантов.
• Один адаптер для нескольких адаптируемых объектов. В некоторых случаях удобно
создать такую архитектуру системы, в которой объект-адаптер являлся бы ча-
стью рабочей среды. Такой адаптер часто работает как посредник между сис-
темой и несколькими адаптируемыми объектами.
• Адаптеры, не базирующиеся на интерфейсе. Использование интерфейсов языка
Java позволяет создавать очень гибкие адаптеры. Однако бывают ситуации, в
которых применения интерфейсов невозможно. Например, интерфейсы ока-
зываются бесполезными, когда нужно адаптировать готовый компонент, кото-
рый при разработке не реализовывал ни одного интерфейса. В таких случаях
можно воспользоваться шаблоном Adapter, не использующим интерфейсов.
Конечно, за такое решение приходится расплачиваться потерей гибкости по-
лученной системы.
• Два интерфейса: один между вызывающей средой и адаптером, а второй — между
адаптером и адаптируемым объектом. Дополнительный промежуточный слой,
образуемый интерфейсом, который помещают между вызывающей средой и
адаптером, облегчает добавление новых адаптеров во время работы системы.
В то же время интерфейс, находящийся между объектом-адаптером и адапти-
руемым объектом, обеспечивает возможность динамической подгрузки по-
следнего во время работы приложения. Наличие двух таких интерфейсов дела-
ет возможной разработку полноценной архитектуры системы с подключаемы-
ми модулями, в которой адаптируемые объекты без каких-либо проблем могут
подключаться к системе "на ходу".

Родственные шаблоны
К родственным можно отнести следующие шаблоны.
• Bridge (стр. 164). Хотя шаблоны Adapter и Bridge очень похожи, они имеют
разное назначение. Шаблон Bridge разделяет абстракцию компонента от его
реализации, тем самым позволяя изменять любую составляющую независимо от
другой. Шаблон Adapter позволяет лишь использовать готовый объект сторон-
него разработчика, несовместимый с разрабатываемой системой.
• Decorator (стр. 180). Шаблон Adapter предназначен для изменения интерфейса
объекта с сохранением его функциональности. Шаблон Decorator, наоборот,
оставляет интерфейс объекта неизменным, но при этом меняет его функцио-
нальность.
• Proxy (стр. 209). И шаблон Adapter, и шаблон Proxy предоставляют интерфейс с
объектом. Различие между ними состоит в том, что интерфейс, предоставляе-
мый шаблоном Adapter, отличается от интерфейса объекта, тогда как интер-
фейс, предоставляемый шаблоном Proxy, совпадает с ним.
• Business Delegate [CJ2EEP]. Шаблон Business Delegate может использоваться
для тех же целей, что и шаблон Proxy. Иными словами, объект, созданный в со-
ответствии с шаблоном Business Delegate, может на локальном уровне пред-
ставлять уровень бизнес-модели. Кроме того, такой объект может работать и
как объект-адаптер, обеспечивая взаимодействие несовместимых систем.

