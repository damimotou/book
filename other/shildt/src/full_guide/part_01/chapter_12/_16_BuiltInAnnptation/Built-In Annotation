В Java определено немало встроенных аннотаций. Большинство встроенных
аннотаций имеют специальное назначение, но девять из них - общее назначение.
Следующие четыре аннотации из этих девяти импортируются из пакета
java.lang.annotation: @Retention, @Documented, @Target и @Inherited. А еще пять
аннотаций - @Override, @Deprecated, @FunctionalInterface, @SafeVarargs
и @SuppressWarnings - входят в состав пакета java.lang. Каждая из них описана
ниже.

На заметку! В версии JDK 8 пакет java.lang.annotation был дополнен аннотациями
@Repeatable и @Native. Первая из них служит для поддержки повторяющихся аннотаций,
как поясняется далее в этой главе, а вторая - для аннотирования полей, доступных из
платформенно-ориентированного кода.

@Retention - применяется только в кач-ве аннотации к др. аннотациям. Определяет
правило удержания аннотации (enum RetentionPolicy)

@Documented
Служит маркерным интерфейсом, сообщающим инструментальному средству
разработки, что аннотация должна быть документирована. Она предназначена
для применения только в качестве аннотации к объявлению другой аннотации.

@Target
Задает типы элементов, к которым можно применять аннотацию. Она предназначена
для применения только в качестве аннотации к другим аннотациям.
Аннотация @Target принимает один аргумент, который должен быть константой
из перечисления ElementType. Этот аргумент задает типы объявляемых
элементов, к которым можно применять аннотацию. Эти константы приведены
в табл. 12.1 вместе с типами объявляемых элементов, к которым они относятся.
В аннотации @Target можно задать одно или несколько значений этих констант.
Чтобы задать несколько значений, их следует указать списком, заключив
в фигурные скобки. Например, чтобы указать, что аннотация применяется только
к полям и локальн ым переменным, достаточно определить следующую аннотацию
@ T a r ge t :
@ T a r g e t ( { Element Type.FIELD, ElementType.LOCAL_VARIABLE } )

Таблица 12.1. Константы из перечисления ElementType
------------------------------------------------------------------------------
Целевая константа   Объявляемый элемент, к которому можно применять аннотацию
------------------------------------------------------------------------------
ANNOTATION ТУРЕ     Другая аннотация
CONSTRUCTOR         Конструктор
FIELD               Поле
LOCAL_VARIABLE      Локальная переменная
METHOD              Метод
PACKAGE             Пакет
PARAMETER           Параметр
ТУРЕ                Класс, интерфейс или перечисление
ТУРЕ_PARAMETER      Параметр типа (since JDK 8)
ТУРЕ_USE            Использование типа (since JDK 8)

В отсутствие обозначения @Target аннотацию можно применять к любому
объявляемому элементу, за исключением пара метров типов. Именно ноэтому зачастую
лучше указывать целевые константы явным образом, чтобы ясно обозначить
назначение аннотации.

@Inherited - маркер, которую можно применять только в другом объявлении
аннотации. Более того, она оказывает воздействие только на те аннотации, которые
будут применяться в объявлениях классов.
Аннотация @Inherited обусловливает наследование аннотации из суперкласса в подклассе.
Так, если конкретная аннотация запрашивается в подклассе, то в отсутствие этой аннотации
в нодклассе проверяется ее присутствие в суперклассе. Если занрашиваемая аннотация присутствует
в суперклассе и аннотирована как @Inherited, то она будет возшращена по запросу.

@Override - маркер, которую можно применить только в методах. Метод, аннотированный как @Override,
должен переопределять метод из суперкласса.
Если он этого не сделает, во время компиляции возникнет ошибка. Эта аннотация гарантирует, что метод из суперкласса
будет действительно переопределен, а не просто перегружен.

@Deprecated - маркер обоаначает, что объявление устарело и должно быть заменено
более новой формой.

@FunctionalInterface - маркер внедрена в версии JDK 8 и предназначена для применения в интерфейсах.
Она обозначает, что аннотируемый интерфейс является функциональным, т.е. содержит один и только один абстрактный метод.
Функциональные интерфейсы применяются в лямбда-выражениях (подробнее о тех и других речь пойдет в главе 15).
Если же аннотируемый интерфейс не является функциональным, то во время компиляции возникает ошибка. Следует,
однако, иметь в виду, что для создания функционального интерфейса аннотация @FunctionalInterface не требуется.
Следовательно, эта аннотация носит исключительно информативный характер.

@SafeVarargs - аннотация-маркер, применяемая в методах и конструкторах. Она указывает
на отсутствие каких-нибудь небезопасных действий, связанных с параметром
переменной длины. Эта аннотация служит для подавления непроверяемых предупреждений,
возникающих в коде, который в остальном является безопасным, в связи
с применением неовеществляемых типов аргументов переменной длины и получением
экземпляра параметризированного массива. (Неовеществляемый тип - это,
по существу, обобщенный тип, как поясняется в главе 14, посвященной обобщениям.)
Эту аннотацию следует применять только к методам или конструкторам с переменным
количеством аргументов, объявляемым как static или final.

@ SuppressWarnings - обозначает, что следует подавить одно или несколько предупреждений,
которые могут быть выданы компилятором. Подавляемые предупреждения
указываются по имени в строковой форме.









